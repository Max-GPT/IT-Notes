# Java 学习笔记

## 文件的后缀
| 阶段  | 文件后缀     | 内容         |
| --- | -------- | ---------- |
| 源代码 | `.java`  | Java 代码    |
| 编译后 | `.class` | JVM 可执行字节码 |


## while (++i > 0)
```
public class Test {
   public static void main(String[] args) {
      byte i = 1;
      while (++i > 0)
         ;
      System.out.print("Loop");
   }
}
```
- byte，占 1 个字节
- 范围：-128 ~ 127
- byte 溢出是 循环回到 -128
- 当 i = -128 → -127 → ... → 0 → 1 ...
- 循环会结束
- 会输出一次Loop，并退出

## if (boolean_expression)
- C/C++ 允许 if(a = b)，因为非零当真（true），0 当假（false）

- Java 不允许，条件必须是 boolean。
```
if(a = b){ //报错
    System.out.println("a=" + a);
}
```
错误原因： 等价于`if (int 1)`

## 基本类型统统不能赋 null
- null 代表的是： “没有对象” / “没有引用”
- 这是 引用类型 的概念
- 基本类型不是 “引用” ，也不存在所谓的“空引用”。

## 常见编译错误
`float f= 1.3`
1.3 是 double 字面量，会自动当成 double，用来初始化 float 会发生 精度下降 → 需要显式强制转换。

`char c = "a"`
"a" 是 字符串，不是字符。 char 必须用单引号 `'a'`。

`boolean d = null`
Java 中 boolean 不是引用类型，不能赋 null。

## 基本数据类型范围
| 类型        | 占用字节 | 范围                                  |
| --------- | ---- | ----------------------------------- |
| **byte**  | 1 字节 | **-128 ~ 127**                      |
| **short** | 2 字节 | **-32768 ~ 32767**                  |
| **int**   | 4 字节 | **-2³¹ ~ 2³¹−1** （大约 −21 亿 ~ 21 亿）  |
| **long**  | 8 字节 | **-2⁶³ ~ 2⁶³−1**（要写 long 字面量要加 `L`） |
| **char** | 2 字节 | 0 ~ 65535（无符号，Unicode 编码） |
| **float**  | 4 字节 | 7 位有效数字  | ±3.4E38，要写 float 字面量要加 `f` |
| **double** | 8 字节 | 15 位有效数字 | ±1.7E308（默认浮点是 double）     |
| **boolean** | JVM 未规定实际大小（逻辑上 1 bit） | **true / false** |


## 没有 main 方法
```
public class Test {
   public static void main() {
    System.out.print("aaa");
   }
}
```
- main 方法的参数设置不对，所以没有main方法
- 依然可以通过编译
- 编译器（javac）只检查语法是否正确,不关心你有没有 main 方法。
- 运行时（java）才会去找 main 方法
- 结果是 运行时报错：找不到 main 方法

## Integer
| 方法名            | 作用            | 返回类型    | 举例                                   |
| -------------- | ------------- | ------- | ------------------------------------ |
| **parseInt()** | 字符串 → int     | int     | `int a = Integer.parseInt("12");`    |
| **valueOf()**  | 字符串 → Integer | Integer | `Integer b = Integer.valueOf("12");` |
| **intValue()** | Integer → int | int     | `int c = integerObj.intValue();`     |


##  非法的变量声明
```
float f = 45.0; //错误写法
```
- 45.0 → 默认是 double 类型的字面量
- double 塞进 float，会出现 “可能损失精度” 的错误
- 不允许从 double 自动降级成 float（精度变低）
```
float f = 45.0f;

float f = (float) 45.0; //不推荐
```

## private 成员被子类继承，但不会被子类“继承权限”。
也就是说：
结构继承了，权限不继承。
```
abstract class Animal {
    private int age;

    public void setAge(int age) {
        this.age = age;
    }

    public int getAge() {
        return age;
    }
}
```
- 子类不能直接引用父类private属性
- 但是可以引用父类 public get( ) 间接获取
```
class Dog extends Animal {
    public void bark() {
        // System.out.println(age); // ❌ 编译错误，子类不能访问 private 成员
        System.out.println(getAge()); // ✔ 能通过 public 方法访问
    }
}
```

## 不能把 abstract 和 private 写在同一个方法上

比如：
```
private abstract void test();
```

这不行，因为：

- private 方法不能被继承/重写
- abstract 方法必须被子类重写
- → 完全矛盾
- 但 private 属性、private 普通方法 都能放在 abstract 类里，完全遵守封装原则。

## 三元运算符要求两个分支类型一致
```
int x = 4;
System.out.println("value is " + ((x > 4) ? 99.9 : 9));
```
- 三元运算符返回 后面的值：9
- 但是：`99.9` 是 double，`9` 是 int
- 三元运算符要求两个分支类型一致 → 
- int 会自动提升为 double。
- 所以实际上返回的是 9.0（double 形式）

## constructor = 构造函数

## 构造函数没有返回值
```
public class Person {

    private String name;

    // 构造函数（关键：没有返回值、名字=类名）
    public Person(String name, int age) {
        this.name = name; 
    }
}
```

## 静态变量 实例变量 都可以在定义时直接赋值
```
private static HashMap<String, Supplier> suppliers = new HashMap<>();
```
```
private int stock = 100;
private String category = "未知";
private HashMap<String, String> data = new HashMap<>();
```

## 成员 / 局部 / 实例 / 静态 变量
| 位置          | 名称                       | 特点        |
| ----------- | ------------------------ | --------- |
| **类里（方法外）** | **成员变量**      | 实例变量 + 静态变量    |
| **类里（方法外）** | **实例变量**（没有 static）      | 每个对象一份    |
| **类里（方法外）** | **静态 / 类变量**（static 变量）       | 全类共享一份    |
| **方法内部**    | **局部变量（local variable）** | 方法结束后自动消失 |

## super( )
super() 不是函数，而是 关键字语法
在子类构造函数中，调用父类的构造函数。

1. 你手写 super( )
```
class Child extends Parent {
    Child() {
        super();  // 调用父类构造函数
        System.out.println("子类构造");
    }
}
``` 
2. 你不写 super( )，Java 会自动帮你写
```
Child() { 
    // Java 会自动加：super();
}
```
但前提是：父类必须有 无参构造函数。

## 三元运算符
```
int age = 20;
String type = age >= 18 ? "adult" : "child";
```
三元运算符可以嵌套，比如：
```
int score = 85;
String grade = score >= 90 ? "A" :
               score >= 80 ? "B" :
               score >= 70 ? "C" : "D";

System.out.println(grade); // B
```

## 逻辑运算符 短路运算
| 运算符 | 名称            | 是否短路 | 用途                     |
|--------|------------------|----------|---------------------------|
| `\|\|`   | 逻辑 OR          | ✔ 会短路 | if 条件判断（推荐）       |
| `&&`   | 逻辑 AND         | ✔ 会短路 | if 条件判断（推荐）       |
| `\|`    | 位 OR            | ✘ 不短路 | 位运算，不推荐用于逻辑     |
| `&`    | 位 AND           | ✘ 不短路 | 位运算，用于 boolean 有风险 |



## 关键字static + final
static：全程序共享，整个程序里只有一份
- static 变量 → 一份，共享
- static 方法 → 不用 new 对象就能用
- static 类 →（只能用于内部类，不是所有类都可以 static）

final：不能被重新赋值 / 不能被修改
- final 变量 → 不能重新赋值
- final 方法 → 不能被子类重写
- final 类 → 不能被继承
- 如果 final 是对象，里面的属性还是能改的（引用不能改，对象内容可以改）


## 注释
`/** ... */` Javadoc 注释 文档注释

`/* ... */` 普通块注释


## Java 命名规范
| 项目  | 写法例子                 | 是否大写 |
| --- | -------------------- | ---- |
| 类名  | `String`, `MyClass`  | 大写开头 |
| 方法名 | `print`, `getName()` | 小写开头 |
| 变量名 | `age`, `userName`    | 小写开头 |
| 常量名 | `MAX_LENGTH`, `PI`   | 全大写  |
