# Spring Boot
## 目录
- [Autowired](#Autowired)
- [DI](#di依赖注入)
- [bean](#bean)
- [Spring Boot 项目结构](#spring-boot-项目结构)
- [Controller 和 RestController](#controller-和-restcontroller)
- [响应体](#响应体)
- [HTTP方法](#http方法) 
- [反序列化](#反序列化)
- [ajax](#ajax)
- [前后端分离](#前后端分离)

## Autowired
wired = 有线 / 接线

autowired = 自动注入 / 自动装配

#### `@Autowired` 的作用：
- 把 Spring 容器里的 Bean，自动注入到你需要的地方。
#### `@Autowired` 本质上是什么？
- `@Autowired` = Spring 的依赖注入（DI）注解。
- 它配合：Bean / IOC 容器 一起工作。

## DI（依赖注入）
Spring 在启动时帮你：
- 创建对象
- 处理对象之间的依赖关系
- 自动装配（注入）
```
@Service
public class UserService {
}
```
```
@RestController
public class UserController {

    @Autowired
    private UserService userService;
}
```
✔ UserService 自动注入到 UserController

## `bean`
- Bean = 被 Spring 管理的对象
- 有特定的 @ 注解 =
- 本质是把这个类交给 Spring，当成一个 Bean 来管理
- bean 是 spring 自带的机制

## Spring Boot 项目结构
```
src/main/java
 └── com.example.demo
     ├── DemoApplication.java  ⭐ 启动类
     ├── controller
     ├── service
     ├── mapper / repository
     └── entity
```
#### 启动类
```
@SpringBootApplication
public class DemoApplication {
    public static void main(String[] args) {
        SpringApplication.run(DemoApplication.class, args);
    }
}
```
只关心一件事：能跑起来

## Controller 和 RestController
```
@Controller        // 返回页面（HTML）
@RestController    // 返回数据（JSON / String）
```
```
@Controller
@RequestMapping("/page")
public class PageController {

    @GetMapping("/hello")
    public String hello() {
        return "hello";
    }
}
```
- 返回的不是字符串 "hello"！
- Spring 认为它是一个页面名
- Spring 会去找：
```
resources/templates/hello.html
```
- 然后把这个 HTML 页面返回给浏览器。
- 常用于：`Thymeleaf` / `JSP`

### @RestController
```
@RestController
public class UserController {
```
这行代码等价于：
```
@Controller
@ResponseBody
```
@ResponseBody 才是“写进响应体”的开关

@RestController
= 默认所有方法都有 @ResponseBody

#### 正确的“心智模型”是：
|注解|作用|
|---|---|
|@PostMapping：|路由规则|
|@RequestBody：|数据从哪来|
|@ResponseBody / @RestController：|数据到哪去|

## 响应体
- 响应体（Response Body）
- 服务器真正“回给客户端的内容”
#### 一次完整 HTTP 请求 = 三个部分
当你访问：
```
http://localhost:8080/user/hello
```
服务器返回的不是一句话，而是一个 HTTP 响应，它长这样（简化版）：
```
HTTP/1.1 200 OK        ← 状态行
Content-Type: text/plain;charset=UTF-8  ← 响应头

Hello Spring Boot     ← 响应体
```
| HTTP 部分 | 类比             |
| ------- | -------------- |
| 状态码     | 快递状态（已签收 / 失败） |
| 响应头     | 快递单（说明内容是什么）   |
| **响应体** | **包裹里的东西本身**   |

## HTTP方法
| 操作 | HTTP 方法     |
| -- | ----------- |
| 新增 | POST        |
| 删除 | DELETE      |
| 修改 | PUT / PATCH |
| 查询 | GET         |

## 反序列化 @RequestBody
前端发请求：
```
POST /user
Content-Type: application/json

{
  "name": "Tom",
  "age": 20
}
```
```
// controller层获取json数据
// 并放入user对象中
// 这个自动化步骤靠着就是@RequestBody

@PostMapping
public User create(@RequestBody User user) {
    return userService.create(user);
}
```
Spring 会做三件事：

1️⃣ 从 HTTP 请求体 里读取 JSON

2️⃣ 把 JSON → Java 对象（User）

3️⃣ 传给你这个方法

📌 这个过程叫：反序列化

| 来源            | 注解                 |
| ------------- | ------------------ |
| URL 参数        | `@RequestParam`    |
| 路径变量          | `@PathVariable`    |
| **请求体（JSON）** | **`@RequestBody`** |


## ajax 

## 前后端分离
```
Controller → JSON → 前端（Vue / React）
```

## Thymeleaf （前后端不分离 / 半分离）
- Thymeleaf 是一个「服务端模板引擎」，用来在 Spring（尤其是 Spring Boot）里生成 HTML 页面。
- 后端拿到数据 → 生成 HTML → 返回给浏览器
- 不是返回 JSON，而是直接返回网页。
```
浏览器
  ↓ 请求
Controller
  ↓
Thymeleaf（把数据塞进 HTML 模板）
  ↓
HTML 页面
```




## dto
DTO（Data Transfer Object）

用来在层与层之间传数据的对象，不负责业务、不负责持久化。

Entity 为数据库服务，DTO 为“传输”服务
```
[Controller]
   ↓  ↑
  DTO
   ↓
[Service]
   ↓
Entity
   ↓
[Mapper]
```

## WHERE 1 = 1
```
SELECT * FROM user
WHERE 1 = 1
  <if test="name != null">
    AND name = #{name}
  </if>
  <if test="age != null">
    AND age = #{age}
  </if>
```
- 所有条件统一加 AND
- 不用判断是不是第一个
- SQL 结构超级干净
- Mybatis 标签结构

## Mapper / Repository / DAO
- 本质都是“数据访问层（持久层）
- DAO = Data Access Object 
- DAO 是一个设计模式概念
- Mapper = DAO（在 MyBatis 语境下）


## 为什么 `Service` 能直接调用 `Mapper 接口`？
`Service` 能直接调用 `Mapper 接口`，
是因为 `MyBatis` 在运行时生成实现类，
`Spring` 把它当成 `Bean` 注入进来。
- “底层公式”

`Service 调 Mapper` =
`Spring 注入` + `MyBatis 动态代理`

## `Lombok`
- `Lombok` 是一个 Java 工具库
- 用注解在“编译期”自动生成样板代码。
- Lombok 在编译阶段“插入”代码，不是运行时反射。
- Lombok ❌ 不是 Spring 的一部分
- Lombok ❌ 不创建 Bean
- Lombok ❌ 不参与 IOC / DI
- 它只是省代码，不改变 Spring 原理。
- 自动生成 getter / setter / 构造方法 / toString / equals / hashCode


## `MyBatis`
- `MyBatis` 不是 `Spring` 自带的机制。
- 它是一个独立的「持久层（数据库）框架」
- 只是和 `Spring` 集成得非常好。
- `MyBatis` 负责：
把你写的 SQL，执行到数据库里，并把结果封装成 Java 对象。
- Java 代码  ⇄  SQL  ⇄  数据库
```
Controller  →  Service  →  Mapper  →  数据库
           Spring         MyBatis
```
- Controller / Service：Spring 管
- 事务 / Bean：Spring 管
- Mapper / SQL：MyBatis 管

#### MyBatis 在 spring 里怎么写
- interface：定义“我能干什么”
- XML：定义“SQL 怎么写”
- MyBatis：把两者绑定起来


## Java Web 技术演进
```
Servlet  →  JSP  →  Struts / JSF 等 MVC 框架  →

Spring MVC  →  Spring Boot
```
Servlet 是底层标准 →  サーブレット

Struts 曾经风光但现在淘汰 → ストラッツ 

Spring MVC 成为主流 → 

Spring Boot 把 Spring MVC 打包成更现代的方式，如今是绝对主流


| 名字 | 含义 | 为什么这样叫？|
| ------------| --------- | ---------- | 
| **Servlet** | 服务小程序 | Serve（服务） + let（小东西） → “小服务程序”。处理 HTTP 请求的 “小服务组件” |
| **Struts**  | 支架、骨架结构 | 支柱 / 框架。它是 Web 应用的“骨架结构”，支撑你的 MVC 逻辑 |
| **Spring**  | 春天 | 让 Java 企业开发重新变得简单、轻松，就像“春天”一样恢复生机。于是就叫做 —— Spring。强大但复杂的框架 |
| **Spring Boot** | Spring 的启动工具 | 自动配置，快速启动 Spring | 
